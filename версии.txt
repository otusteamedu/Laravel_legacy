Занятие 10
==========
2019.12.09 Создал пустой Laravel проект.

2019.12.09 Создал скелет приложения : страницы
  - index
  - login
  - register
  - home
  - katalog

Занятие 11
==========
2019.12.13 Добавил колонки в миграцию _create_users_table.php
2019.12.13 Создал модель Item и её миграцию миграцию _create_items_table.php
2019.12.13 Создал модель UserAccount и её миграцию миграцию _create_user_accounts_table.php
2019.12.13 Создал модель Order и её миграцию миграцию _create_orders_table.php

2019.12.20 Переименовал поле C в таблице create_user_accounts_table : C => discount_coefficient
2019.12.20 Переместил классы моделей из app/ => app/Models
           Прописал в каждом классе namespace App\Models;
           В composer.json в autoload psr-4 добавил  "App\\Models": "app/Models"


Занятие 12
==========
2019.12.26 Переименовал модель UserAccount => Account для простоты. Также переименовал миграцию.

2019.12.26 Добавил foreign key в миграцию _create_user_accounts_table.php
2019.12.26 Добавил foreign key в миграцию _create_orders_table.php

2019.12.26 Добавил отношение one-to-one в модель User.
2019.12.26 Добавил отношение has-many в модель User.
2019.12.26 Добавил отношение belongs-to в модель Order.

2019.12.26 поменял локаль Faker'a в config/app.php

2019.12.27
  Создал фабрики
    UserFactory
    AccountFactory
    ItemFactory
    OrderFactory

  Создал сидеры
    UsersTableSeeder
    ItemsTableSeeder

Занятие 12.2
============
2019.12.31
Корректировка задания 12.2
  Добавил PHPdoc комментарии
  Вернул поля password и rememberToken в миграцию _create_users_table
  Вычленил из UsersTableSeeder => AccountsTableSeeder и OrdersTableSeeder

Занятие 14
==========
2020.01.01

  Задача : создать простейшую админку, через которую я вручную могу добавлять, обновлять, удалять пользователей.

  Часть 1 : Написал работающие CRUD-операции.

  Создал вьюшки:
    views/pages/admin/
        index.blade.php     - показать список всех пользователей
        show.blade.php      - показать информацию по конкретному пользователю. Редактировать нельзя.
        edit.blade.php      - показать информацию по конкретному пользователю с возможностью ввода данных и их сохранения.
        create.blade.php    - показать форму, где можно ввести данные нового пользователя и сохранить их.

  Для каждой новой вьюшки создал их CSS-файлы и прописал эти CSS-файлы внутри webpack.mix.js

  Сгенерировал ресурсный контроллер UserController.php

  Создал папку, а в ней - отдельные реквест-классы.
  Эти реквест-классы использую в контроллере UserController.php для того, чтобы валидировать данные из форм вьюшек.
  app\Http\Requests\
    StoreUserRequest.php
    UpdateUserRequest.php

  2020.01.05
  Часть 2 : Паттерн Репозиторий.
  Статья : https://www.larashout.com/how-to-use-repository-pattern-in-laravel

  Создал app\Repositories\
            UserRepository.php
            UserRepositoryInterface.php
            BackendServiceProvider.php

  В config\app.php, в списке сервис-провайдеров, прописал BackendServiceProvider.

  Немного изменил UserController.php, где и использую паттерн Репозиторий.

Часть 3 :
Добавил handler'ы.
Бизнес-логику можно вывести в handler'ы.
Services/StoreUserHandler.php

Добавил сервисы.
Они вызывают handlerы.
Services/UserService.php

Обновил работу с реквестами : добавил Requests\FormRequest.

Часть 4 :
Интегрирую сервис UserService в контроллер UserController.

Часть 5 :
Реплицирую структуру папок, как в проекте у Егора.
Получилось слишком сложно и запутанно. Очень труднозапоминаемые пути к папкам.

[app]
    [Models]
        Account.php
        Item.php
        Order.php
        User.php

    [Http]
        [Controllers]
            [CMS]
                [Users]
                    [Requests]
                        CreateUserRequest.php
                        UpdateUserRequest.php
                    UsersController.php
        [Requests]
            FormRequest.php

    [Services]
        [Users]
            [Handlers]
                CreateUserHandler.php
            [Repositories]
                UserRepository.php
                UserRepositoryInterface.php
            UsersService.php
            UsersServiceProvider.php

    Также пришлось добавлять конструкцию в routes/web.php
    Пришлось убрать 'cms' из Route::prefix('')

    Зарегистрировал класс и интерфейс репозиториев по своему, через UsersServiceProvider.php

Часть 6 : Исправление "косячков".

    Убрал лишние комментарии.

    Вместо использования констант типа define('USER_SOURCES', config('shop.sources'));
    использую config('shop.sources');

    Использую именованные маршруты. Пример : redirect('/users/') => стало redirect(route('cms.users.index'))

    Добавил ещё один handler UpdateUsersHandler.php => вставил его в UsersService.

Занятие 16
==========
2020.01.09 Часть 1
Задача : Подготовить среду к авторизации.

Выполнил команды :
composer require laravel/ui
php artisan ui vue --auth

При выполнении npm install && npm run dev
получил ошибку о несовместимости версий vue-loader и vue-template-compiler

Устранил ошибку командой переустановки :
npm install -D vue-loader vue-template-compiler
См. https://vue-loader.vuejs.org/guide/#vue-cli

Потом успешно выполнил npm install && npm run dev

2020.01.10

Часть 2
Создал страницу профиля, где рядовой пользователь может редактировать свои контактные данные."

Часть 3
Поменял настройки в app/config/auth.php
+ PagesController.php

Попытался применить правила авторизации использую фасад Gates и политику UserPolicy.php.

2020.01.13
Часть 4
Применяю совет Егора.
Удалось решить проблему используя и Gates, и UserPolicy.php

Часть 5
На ревизию Егору. Пока не отсылал.

Себе на будущее. Разберись как рационально вызывать View::share в контроллерах.
См. blocks/top-nav.blade.php
    blocks/logout.blade.php
    PagesController.php@checkUserStatus() && construct()

2020.01.24 Часть 6
Рефакторинг.

Создал BladeServiceProvider.php
Он нужен, чтобы показывать или скрывать в меню ссылки, в зависимости от статуса пользователя :
залогинен или нет, админ или нет.

Добавлена регистрация.

Пользователь может зарегистрироваться и залогиниться.

Пользователь имеет 3 уровня доступа : 1 - простой пользователь, 2 - модератор, 3 - администратор.
В проекте же пока использую только уровни 1 и 3.

Гостям в меню видны ссылки : Главная, Каталог, Вход, Регистрация.
После залогинивания, в меню добавляются дополнительные ссылки : Мой кабинет, Мой профиль, Выйти.
Если пользователь - админ, то у него видна ещё одна дополнительная ссылка : Пользователи.

После залогивания, пользователь попадает в Мой кабинет (/home).

Что разрешено пользователю :
Пользователь может перейти в свой профиль (/profile) и там редактировать свои данные.

Что разрешено администратору :
Администратор имеет доступ к списку пользователей через uri '/users'
Рядовой пользователь не имеет доступа к этому списку => ошибка 403

Администратору разрешены любые действия с пользователями :
/users      - просмотреть список пользователей
/users/2    - просмотреть данные пользователя с id = 2
редактирование данных пользователя
удаление пользователя
создание нового пользователя
Рядовой пользователь при попытке совершить какое-то действие из перечисленных выше
должен получать ошибку 403.

Для реализации правил авторизации,
    - создал middleware CheckAdmin.php
    - вызываю этот middleware в конструкторе UsersController.php

В итоге, оказались ненужными :
    - созданные Gateы в AuthServiceProvider.php,
    - политика в UserPolicy.php

Весь этот код будет удален в Части 7 за ненадобностью.


2020.01.26 Часть 7
Удаляю неиспользуемый для авторизации код.

2020.01.29 Часть 8
Исправления по комментариям Егора.


Занятие 17 - Тестирование
==========
2020.01.31 Часть 1
Создал несколькоо тестов для UsersController.php

2020.02.04 Часть 2
Исправление по рекомендациям Егора.
Но в процессе, очень сильно отрефакторил свой код.

Рефакторинг 1
Т.к. много методов используют один и тот же список роутов,
то вместо аннотаций типа
* @testWith
* ["cms.users.index"]
* ["cms.users.create"]

Завёл два дополнительных метода-провайдера данных :
pubclic function routesToTestWithoutUserData() {...}
pubclic function routesToTestWithUserData() {...},
внутри которых перечисляю список роутов.

Рефакторинг 2
Был один раздутый класс UserControllerTest.php, внутри которого тестируются
роуты для трёх типов пользователей : гости (не авторизованные), обычные пользователи и админы.

Внутри UserControllerTest.php также были вспомогательные методы.
Я разбил UserControllerTest.php на 4 отдельных класса :
- ParentTest.php - базовый родительский класс, содержит общие полезные методы для классов-потомков.
Классы потомки, каждый из которых тестирует роуты для своей категории пользователей :
- GuestsTest.php    относится к @group tg
- UsersTest.php     относится к @group tu
- AdminsTest.php    относится к @group ta

Занятие 18 - Логирование
==========
2020.02.06 Часть 1
Добавил простое логирование.
Настройка Slack:
    - Зарегистрировался в Slack.
    - Создал workspace 'MyWorkSpace'
    - Создал канал 'laravel'
    - Создал приложение 'laravel-notifications'
Laravel gри попытке отправить уведомление в Slack, ругался :
PHP Fatal error:  Uncaught Error: Call to undefined function Monolog\Handler\curl_init()

Стал настраивать Laravel:
    - Установил : composer require laravel/slack-notification-channel # из инструкции Laravel - НЕ ПОМОГЛО
    - Установил : composer require guzzlehttp/guzzle # из видео YouTube - НЕ ПОМОГЛО

Дело в том, что curl не был настроен в веб-сервере.
Тогда установил curl. Мне помогли 2 статьи :
    - Проверим а установлен ли модуль curl в веб-сервер : https://www.discussdesk.com/how-to-install-curl-and-check-curl-is-enabled-in-web-server.htm
    - Установка curl в веб-сервер apache : https://www.discussdesk.com/how-to-install-curl-and-check-curl-is-enabled-in-web-server.htm

Занятие 19 - Middleware
==========
2020.02.16 Часть 1

Написал группу middleware для фильтрации HTTP-запросов.

Задача - проверить входящий HTTP-запрос. Если запрос не прошёл проверку,
то будет редирект на пустую страницу (реализовано сейчас) или страницу ошибки (возможно в будущем).

Проверяться будет следующее :
- Сайт в режиме локальной разработки или нет
- Поисковый ли бот зашёл на сайт
- Заход с админовского ip или нет
- Проверка настроек видимости сайта : показывать только на мобильных экранах или нет, показывать запрещённым странам или нет, сайт вообще работает

Для реализации этого функционала создал цепочку middleware :
->checkIfLocalhost
->checkIfSearchBot
->checkIfAdminIP
->checkSiteSettings
->checkIfMobileDevice
->checkIfCityIsBanned
Их локация : app\Http\Middleware\SiteAccess
Все эти посредники объединены в группу "apply-site-filters" в Kernel.php.

Для проверки работы группы посредников, в web.php добавил:
Route::get('/katalog', 'PagesController@katalog')->name('katalog')->middleware('apply-site-filters');
Route::get('/blank', 'PagesController@blank')->name('blank');

Некоторые настройки сайта, такие как
- сайт включён или нет
- проводить фильтрацию по ip или нет (для исключения "запрещённых" к показу городов)
- ограничивать показ сайта только на мобильных устройствах или нет
хранятся в app\Http\Middleware\SiteAccess\siteSettings.json

Содержимое siteSettings.json в будущем будет меняться отдельной страницей.

2020.02.21 Часть 2
Ранее, результат проверки условия сохранял в посреднике, в методе handle(), в объекте реквест :
$request->checkNeeded = $nextCheckNeeded;

Потом, внутри следующего посредника, проверял условие предыдущей проверки:
if($request->checkNeeded)

В этой версии создал класс для хранения значения проверки CheckResult.php

2020.02.21 Часть 3
Перенос сторонней библиотеки Mobile_Detect.php в Сервисы: App\Services\MobileDetection\Mobile_Detect

2020.02.21 Часть 4
Перенёс список админовских ip из app/Http/Middleware/SiteAccess/adminIPs.json в
app/config/admin_ips.php

2020.02.21 Часть 5
Перенёс код в сервисы :
    app/Services/CityByIpResolver
    app/Services/MobileDetection
    app/Services/SearchBotByIpResolver

2020.03.12 Часть 1
Добавил кэш-репозиторий : CacheRepository.
Пока кэшируется только запрос на получение всех пользователей.

2020.03.14 Часть 2
Для событий
    - Пользователь создан
    - Пользователь обновлен
    - Пользователь удалён
Создал слушателя ClearUserCache.php Внутри этого класса вызываю метод кэш-репозитория по полной очистке кэша.

2020.03.14 Часть 3
Прогрев кэша.

Описание частей 1 - 3
Кэш использую только для того, чтобы хранить всех пользователей из таблицы users. При добавлении нового пользователя, или редактировании, или удалении пользователя - инвалидирую кэш.

Обращение к кэшу происходит, когда пользователь-администратор загружает вью 'pages.admin.index'. См. вызов в UsersController@index()

Реализация кэша в папке [app\Services\Cache]
В интерфейсе CacheRepositoryInterface.php есть 3 метода для работы с кэшем :
getAllUsers(), clearUserCache(), warmupUserCache().

Ради простоты решил обойтись без CacheService.php и xxxCacheHadler.php классов.

Для инвалидации кэша, слушаю события в папке [app\Services\Events\Models\User\].

Для прогрева кэша слушаю : только-что залогинившийся пользователь администратор или нет. Если да, то прогреваю кэш.
Использую 2 пары "событие-слушатель". См. EventServiceProvider.php
Событие Illuminate\Auth\Events\Login вызывает слушатель App\Listeners\CheckUserIsAdmin, который проверяет : пользователь администратор или нет ? Если ответ true, то вызывается событие App\Services\Events\Models\User\UserIsAdmin, которое обрабатывает слушатель App\Listeners\WarmUpUserCache.

2020.03.18 den-abidov/hw21.1
Часть 1
Создал команду для прогрева кэша.
Добавил команду в крон.

Часть 2
Усложнение. Запуск email-рассылки через команду из консоли.

Создал шаблон письма : views/emails/new_action.blade.php
Шаблонов можно создать сколько угодно и далее в команде указывать какой именно шаблон письма использовать в рассылке.

В .env файл добавил параметры для настройки почтового сервиса mailtrap.io

Создал команду app/Console/Emails/SendEmail.php

Часть 3
Организация email-рассылки по расписанию.

Создал модель Email. Прописал отношения в моделях Email и User.

Создал миграцию create_emails_table.
Мигрировал командой : $ php artisan migrate --path=/database/migrations/2020_03_22_082338_create_emails_table.php

Создал фабрику EmailFactory.php - понадобится для генерации новой записи Email.

Создал консольную команду SeedEmailsTable.php

Создал класс правил EmailRules.php
--
Сейчас можно сгенерировать email-рассылку консольной командой :
$ php artisan emails:seed new_action
Вместо 'new_action' можно использовать другие аргументы. См.Models/Email.php

В результате в таблице emails появятся строки о том, какому пользователю нужно будет отправить письмо
по шаблону views/emails/new_action.blade.php
--
Чтобы запустить email-рассылку, по заданию в таблице emails, нужно вызвать команду :
$ php artisan emails:send new_action --id=all

Рассылка успешно ваыполняется, ОДНАКО, нужно ещё пометить в таблице emails, что соот-ее письмо
для указанного пользователя успешно отправлено. Это буду делать в следующей части.

Часть 4
Исправил app/Console/Commands/Emails/SendEmail.php
Теперь, после отправки письма получателю, в таблице emails делается пометка, что письмо больше отправлять не надо.
