Пример из контроллера на Yii2, в котором нарушаются принципы Dependency inversion и Open-closed.
Проблема — метод зависит от класса MembersSearch. Для того чтобы избавится от зависимости конкретного класса, надо сделать так, чтобы метод actionIndex зависел от абстракции, т.е. от интерфейса MembersInterface.

```php
    /**
     * @return string
     */
    public function actionIndex(Request $request, Members $members)
    {
        $model = $members->search($request->queryParams);

        return $this->render('index', [
            'model' => $model,
        ]);
    }

    /**
    * Interface MembersInterface
     */
    interface MembersInterface
    {
        /**
         * @param $params
         * @return mixed
         */
        public function search($params);
    }
    
    /**
     * Class Members
     */
    class Members implements MembersInterface
    {
        /**
         * @param $params
         */
        public function search($params){/*...*/}
    }
```

Похожий пример, только тут ещё нарушается принцип SRP.
Необходимо вынести работу с моделью в репозиторий, в репозитории можно реализовать шаблон "Строитель".  

```php

function actionAdd(PagesRepository $pagesRepository)
{
    $pagesRepository->builDefaultPage()->savePage();

    return $this->render('index', [
        'model' => $pagesRepository,
    ]);
}

/**
* Interface PagesRepositoryInterface
*/
interface PagesRepositoryInterface
{

    /**
     * @param  string  $title
     *
     * @return PagesRepository
     */
    public function setTitle(string $title) :PagesRepository;

    /**
     * @param  int  $group
     *
     * @return PagesRepository
     */
    public function setGroup(int $group) :PagesRepository;

    /**
     * @param  string  $type
     *
     * @return PagesRepository
     */
    public function setType(string $type) :PagesRepository;

    /**
     * @return PageModel
     */
    public function savePage() :PageModel;

    /**
     * @return PageModel
     */
    public function builDefaultPage() :PagesRepository;
}

/**
* Class PagesRepository
*/
class PagesRepository implements PagesRepositoryInterface
{
    /**
     * @var PageModel
     */
    private $page;

    public function __construct()
    {
        $this->reset();
    }

    public function reset() :void
    {
        $this->page = new PageModel();
        $this->page->id = \Yii::$app->security->generateRandomString(3);
    }

    /**
     * @param  string  $title
     *
     * @return PagesRepository
     */
    public function setTitle(string $title) :PagesRepository
    {
        $this->page->title = $title;
        return $this;
    }

    /**
     * @param  int  $group
     *
     * @return PagesRepository
     */
    public function setGroup(int $group) :PagesRepository
    {
        $this->page->group = $group;
        return $this;
    }

    /**
     * @param  string  $type
     *
     * @return PagesRepository
     */
    public function setType(string $type) :PagesRepository
    {
        $this->page->type = $type;
        return $this;
    }

    /**
     * @return PageModel
     */
    public function savePage() :PageModel
    {
      return $this->page->save();
    }

    /**
     * @return PagesRepository
     */
    public function builDefaultPage() :PagesRepository
    {
        $this->setTitle(PageModel::PAGE_DEFAULT_TITLE)
            ->setGroup(PageModel::PAGE_DEFAULT_GROUP)
            ->setType(PageModel::PAGE_DEFAULT_TYPE);

        return $this;
    }

}

/**
 * Class PageModel
 */
class PageModel
{
    /** @var string */
    const PAGE_DEFAULT_TITLE = 'Заголовок новости';
    /** @var int */
    const PAGE_DEFAULT_GROUP = 3;
    /** @var string */
    const PAGE_DEFAULT_TYPE = 'news';

    public $id;
    public $title;
    public $group;
    public $type;

    public function save()
    {
        return $this;
    }
}

```

Поскольку эти два ДЗ я сдаю одними из последних, в коде проекта видно как я применяю принципы SOLID на практике.