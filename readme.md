### Д3 №1. Анализ имеющегося проекта  относительно изученных принципов SOLID

`Проект на стадии разработки`

**Коротко о проекте**. Для многих Интернет-магазинов, работающих по цепочке Дилер —> Розничный Интернет-магазин —> Покупатель, существует задача загрузки товарной базы Дилера (Поставщика Supplier) и размещения ее на сайте ИМ. Как правило, поставщиков много, есть пересекающиеся товарные позиции, а исходным материалом для загрузки является:

* файл в формате CSV
* ссылка на выгрузку в формате XML
* ссылка на выгрузку в формате JSON
* сайт для обхода

Сайт поставщика может быть на любой системе управления. Дополнительной сложностью является то, что выполнение какой-либо операции по загруке/выгрузке нельзя выполнить в один шаг на несколько часов. Во-первых, часто есть ограничения по ресурсам на виртуальных площадках, во-вторых одношаговую систему трудно отлаживать, в-третьих ей трудно управлять оператору, так как часто нужно продолжить загрузку с последнего прерывания, приостановить, обработать ошибку.

Структурно система состоит из 3 подсистем:

1. Подсистема загрузки данных
2. Подсистема хранения и управления промежуточным (между целевым сайтом и источником поставщика) хранилищем.
3. Подсистема выгрузки на сайт поставщика.

Выполнение ДЗ (видимо второе тоже) буду вести на нескольких файлах из `подсистемы 1`. Во всех рассуждениях я буду опускать фразу «по моему мнению». В классах есть пояснения по поводу их назначения, которые я не выношу сюда, чтобы не «замусоривать» само ДЗ.

***

Анализ
----

**Класс App\Common\Worker\TaskManager — пошаговое выполнение задач.**

`./src/Common/Worker/TaskManager.php`

1. Данный класс реализует принцип **SRP**, так как единственной его задачей является управление выполнением пошаговых задач, описываемых интерфейсом  IWorkerTask. Есть действия, показывающие текущее состояние загрузчика, а также метод добавления. Метод добавления объекта, мы не считаем другой функцией, так как, по сути, он относится к созданию объекта. Выносить этот функционал в отдельный класс, следуя паттерну Строитель, нет смысла, так как он получает не исходные данные для создания объектов, а ссылки на уже готовые и сконфигурированные объекты  IWorkerTask.

2. Класс не нарушает принцип **OCP**, так как разделён процесс обработки задач и сути самих задач. TaskManager выполняет задачи из списка $arList, не зная о том, что эти задачи делают, следуя контракту (интерфейсу) IWorkerTask. Суть выполняемых задач определяется конкретным классом, реализующим интерфейс  IWorkerTask.

3. Класс следует принципу **LSP**.  TaskManager — абстрактный, его невозможно создать. Использоваться же будут его наследники TaskManagerDB, TaskManagerSess, TaskManagerShedule и т. д., которые конкретизируют способ восстановления и сохранения состояния процесса пошагового выполнения задач: 
    * `TaskManagerDB` — в базу данных, а доступ осуществляется по session_id из HTTP запроса;
    * `TaskManagerSess` — в сессию, session_id передается через сессию;
    * `TaskManagerShedule` — через внешние запуски скрипта, без установленных текущих идентификаторов сессий.

    Т.е. поведение у наследников уточняет базовых функционал, но не изменяет его. В данном случае поведение сохранения/восстановления состояния вообще не описывается в базовом классе.

4. Принцип **ISP**. Тут один короткий интерфейс. Его деление не требуется.

5. Принцип **DIP**. Объекты класса TaskManager будут использоваться, как зависимости в контроллерах-обработчиках запросов. На данный момент точно можно сказать, что TaskManagerDB и TaskManagerSess взаимозаменяемы. Что касается реализации TaskManagerShedule – это не так. Что с этим делать пока неясно, но точно ясно, что необходимо нарисовать диаграмму использования этого класса в сценариях и оттуда уточнить процесс того, как будут подтягиваться состояния TaskManager и как будут подтягиваться обработчики задач IWorkerTask с готовыми конфигурациями. Пока TaskManagerShedule выпадает из этой схемы. Он не подставляем. 

    Объекты класса TaskManager, также могут быть использованы как внедряемые зависимости. Сам TaskManager не может быть внедрен, так как абстрактный, наследники же не дополняют интерфейс, а только уточняют методы загрузки текущего состояния. Т.е., по сути, на этапе внедрения мы определяем, то каким конкретным образом будут инициализироваться параметры текущего состояния процесса.

    Единственной проблемой этого подхода пока заключается в наличии параметра session_id в конструкторе (предполагается, что после создания объекта этот параметр никак не может быть изменен), который никак не может быть определен на этапе внедрения, но, похоже от него необходимо будет отказаться, так как существуют типы загрузки состояния никак не привязанные к какой-либо сессии, например, при вызове через cron. Задавать этот параметр надо будет через setSessionId, а при попытке повторно проинициализировать сессию выкидывать исключение.
    **Итог** — класс будет переработан под возможность внедрения и будет использован как зависимость в контроллере (он же контейнер зависимостей) Symfony.

---

**Класс настройка App\Common\Config\Option (с именем).**

`./src/Common/Config/Option.php`

О нем можно было не упоминать (он слишком мал), если бы только тут не нарушался принцип **OCP**, тут ограничено расширение функциональности. В данном случае считаю это нормальным, так как дальнейшее расширение не планируется, что подтверждено ключевым словом final. Возможные типы настроек перечислены в константах (строка, число, список, булева галочка), а вместо отдельных реализаций Option под свой тип, мы применяет конструкции if...else.

**Класс App\Common\Worker\AbstractWorker – воркер, выполняемая задача.**

`./src/Common/Worker/AbstractWorker.php`

1. Данный класс реализует принцип **SRP**, его единственная задача определяется методами:

    * `doAction()` – выполнить атомарную операцию, например, прочитать из xml-файла часть данных пока не будет сформирован валидный объект предметной области – категория, валюта, товар;

    * `getTotal()` – оценить объем задачи целиком, например, вернуть размер xml-файла в байтах

    * `getCurrent()` – вернуть текущий уровень выполнения, например, позиция каретки в файле в байтах.

2. Принцип OCP реализуется через наследование. Т.е. все указанные методы, т.е. вышеописанный пример с файлом XML будет реализован не в данном классе, а в наследниках. Пример – `DummyWorker`, используемый для отладки.

    ***Тут нужен комментарий преподавателя. В вебинаре этот принцип поддерживался через композицию с другим объектом, который проверял готовность к заказу объекта Order. Т.е. мы могли отвечать на вопрос – может ли покупатель оформить заказ через вызов через интерфейс другого объекта-валидатора. Здесь же расширение функционала происходит через реализацию методов doAction(),getTotal(),getCurrent() в классах-наследниках. Или данный принцип нужно в принципе рассматривать только в контексте передачи ответственности другим объектам.***

3. Принципу **LSP**. Я нашел такую трактовку этого принципа:

    `Функции, использующие указатели ссылок на базовые классы, должны уметь использовать объекты производных классов, даже не зная об этом.`

    Объекты данного класса будут использоваться в объекте методах `TaskManager::process`,  `TaskManager::addTask`. В них объекты воркеров воспринимаются как реализации `IWorkerTask` и не зависят от конкретной их реализации.

4. Принцип **ISP**. Если посмотреть на интерфейс воркеров `IWorkerTask`, то видно, что он большой и да, далеко не каждому воркеру нужно реализовывать все методы интерфейса, но в то же время в функции `TaskManager::process` они все используются и какая-то реализация там быть должна, хотя бы пустая. Для этого как раз и введен абстрактный класс `AbstractWorker`, который реализует часть методов интерфейса `IWorkerTask` единственно возможным способом, а часть методов оставляет с пустой реализацией. В итоге остаются для обязательной реализации только два метода:  
    * doAction() – выполнить атомарную операцию
    * getTotal() – оценить объем задачи целиком.

    Такое я часто видел в фреймворке типа Swing (Java) в обработчиках событий элементов UI. Правда, там реализованы оба подхода:
    * можно реализовывать небольшие интерфейсы с одной функцией например, клик.
    * можно наследоваться от абстрактного класса, если тебе нужно реализовать, например, 3 события из 5 и реализовывать 3 интерфейса будет синтаксически громоздко.
    
**Класс App\Common\Handler\Handler – настраиваемый абстрактный обработчик.**

`./src/Common/Handler/Handler.php`

1. Принцип **SRP**. Видимо на данных момент этот принцип не реализуется, так как класс реализует интерфейс IHandler на который наложены две задачи:
	* Идентификация обработчика `getId()`, `getType()`
	* Возможность конфигурирования `getOptions()`
	
	Разнесу `IHandler` на два:
	* IHandler - специфичный, применимый только для всех обработчиков
	* IConfigurable - возможность сконфигурировать в формах добавления/изменения сущности. Возможно этот интерфейс правильнее оформить в виде трейта.
	
2. Принцип OCP. Расширение функционала планируется через наследование. По сути в достаточно большой цепочке наследников будут реализован функционал AbstractWorker для разных типов задач. Т.е. в итоге вне зависимости от стоящих перед наследниками задач, они должны будут реализовать методы `doAction()` и `getTotal()`

3. Принципу **LSP**. Аналогичен соответствующему пунтку для класса `App\Common\Worker\AbstractWorker`, так как это его наследник. Остальной функционал реализует интерфейс `IHandler`, поэтому конфликтов с принципом **LSP** нет.

4. Принцип **ISP**. Как уже было сказано, интерфейс нужно разделить на `IHandler` и Trait `Configurable`
