<?php

namespace App\Common\Handler;

use App\Common\Config\Config;
use App\Common\Config\Option;
use App\Common\Config\Options;
use App\Common\File;
use App\Common\Download;
use App\Common\FileNotFoundException;

/**
 * Основа для пошагового парсинга XML-файлов. Атомарной операцией считаем разбор Независимого объекта,
 * который не входит в композицию с другим объектом. Независимость объектов в рамках XML - это те, что не подченены
 * друг другу иерархически. Например, в YML товар независим от категории, но логически категории аггрегируют коллекции товаров.
 * Напротив, параметры товаров и товары входят в отношение композиции, не могут рассматриваться отдельно от товара,
 * их нельзя разобрать в рамках одной атомарной операции.
 * Следовательно, для случая YML независимыми объектами яляются категория, товар, валюта, доставка (глобальная)
 *
 * Class XmlParser
 * @package App\Common\Handler
 */
abstract class XmlParser extends Handler
{
    /**
     * @var XMLParserAdapter
     */
    private $parser;

    /**
     * @var array
     */
    private $chains;

    /**
     * @var ParserChain
     */
    private $currentChain;
    /**
     * XmlParser constructor.
     * @param Config $paramValues
     */
    public function __construct(Config $paramValues) {
        parent::__construct($paramValues);
        $this->initRules();
    }

    /**
     * Конфигурируемые настройки
     * @return Options
     */
    public function getOptions(): Options
    {
        return new Options(
            [
                new Option('fileURL', Option::T_STRING, 'Файл для загрузки', ''),
                // new Option('filePath', Option::T_STRING, 'Путь к файлу', ''),
                new Option('authLogin', Option::T_STRING, 'Логин', ''),
                new Option('authPassword', Option::T_STRING, 'Пароль', '')
            ]
        );
    }
    /**
     * В наследниках в эту функцию используем для строительства правил анализа XML-файла
     * @return mixed
     */
    abstract protected function initRules();
    /**
     * Копируем файл во временную папку один подход.
     * Позднее будем использвать App\Common\Handler\Downloader для загрузки по частям;
     *
     * @return bool
     */
    public function initSession(): bool
    {
        $fileURL = $this->getParam('fileURL');
        $dwl = new Download($fileURL);
        $filePath = $dwl->download();

        $file = new File($filePath);
        if(!$file->isExists()) {
            $this->setError(true);
            $this->setMessage("Невозможно скачать файл");
            return false;
        }

        $this->getState()->set('filePath', $filePath);
        $this->getState()->set('filePointer', 0);
        $this->getState()->set('tagStack', []);

        return parent::initSession();
    }

    public function finishSession()
    {
        $filePath = $this->getFilePath();
        $file = new File($filePath);
        $file->delete();

        parent::finishSession();
    }

    /**
     * @return int
     * @throws FileNotFoundException
     */
    public function getTotal(): int
    {
        $filePath = $this->getFilePath();
        $file = new File($filePath);
        return $file->getSize();
    }

    /**
     * @param Config $state
     * @param int $current
     * @return bool|void
     */
    public function init(Config $state, int $current): bool
    {
        if(!parent::init($state, $current))
            return false;

        $this->parser = new XMLParserAdapter($this->getFilePath(), $this);
        $this->parser->setState([
            'offset' => $this->getState()->get('filePointer', $current),
            'stack' => $this->getState()->get('tagStack', [])
        ]);

        $this->initChains();
    }

    public function finish(): Config
    {
        $state = $this->parser->getState();
        $this->setCurrent((int) $state['filePointer']);
        $this->getState()->set('tagStack', $state['stack']);
        return parent::finish(); // TODO: Change the autogenerated stub
    }

    /**
     * Запускаем адаптер потокового XML-парсера
     * @throws \Exception
     */
    public function doAction()
    {
        $this->parser->start();
        $state = $this->parser->getState();
        $this->setCurrent((int) $state['filePointer']);
        // $this->setMessage("Идет обработка XML файла обработано");
        // $parser->add
    }

    private function getFilePath() {
        return $this->getState()->get('filePath');
    }

    public function getCurrentChain(): ?ParserChain {
        return $this->currentChain;
    }

    public function setCurrentChain(ParserChain $chain = null) {
        $this->currentChain = $chain;
    }

    public function initChains() {
        foreach ($this->chains as $chain)
        {
            $allRules = $chain->getAllRules();
            foreach ($allRules as $rule) {
                $xpath = $rule->getPath();
                if($rule->getParent())
                    $this->parser->onElement('chainItem', $xpath);
                else
                    $this->parser->onElement('chain', $xpath);
            }
        }
    }
    public function addChain($xpath, \Closure $callbackIn, \Closure $callbackOut) : ParserChain {
        if(!$this->find($xpath))
            throw new XmlParserException("Цепочка с селектором '".$xpath."' уже существует");

        $chain = new ParserChain($this, $xpath, $callbackIn, $callbackOut);
        $this->chains[$xpath] = $chain;

        return $chain;
    }

    public function startChain(string $path, ParserData $data) {
        $chain = $this->find($path);
        $this->setCurrentChain($chain);
        $chain->callChainRule('', $data, XMLAbstractParser::PHASE_NEW);
    }

    public function closeChain(string $path) {
        $chain = $this->find($path);
        $chain->callChainRule('', null, XMLAbstractParser::PHASE_POST);
        $this->setCurrentChain(null);
    }

    public function callChainRule(string $path, ParserData $data, $nPhase) {
        $chain = $this->getCurrentChain();
        $cpath = $chain->getPath();
        if(strpos($path, $cpath) !== 0)
            return;
        $rpath = substr($path, strlen($cpath));

    }

    public function find($path) {
        return
            (array_key_exists($path, $this->chains)
                && $this->chains[$path] instanceof ParserChain) ?
                $this->chains[$path] : null;
    }
}

class XmlParserException extends \Exception {
}